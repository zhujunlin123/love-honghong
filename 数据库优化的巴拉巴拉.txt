我们网站有1千万条数据，让你对数据库进行优化，有什么好的措施？

	先反问：
		既然有1千万条数据，那咱们网站的并发写操作是不是很大呀？
		
	老板：大呀！
		这种情况，首先看一下数据库的存储引擎是不是使用的innodb，巴拉巴拉。。。
	老板：不大。
	反问：并发量不大，读写数据量是不是很大呀？
		这种情况，首先看一下数据库的存储引擎是不是使用的myisam，巴拉巴拉。。。
		
	分析情况：
		数据量比较大，查询的数据量比较大。
	给出措施：
		利用慢查询日志，找出查询速度慢的sql语句。
		然后，分析sql语句有没有使用索引。
		再针对sql语句，建立合理的索引，巴拉巴拉。。。索引的使用原则

重点！！！！！！！！！！面试技巧

针对数据库的优化措施。
	套路一： 假设反问情况
		数据展示的速度比较慢，有可能是sql语句执行时间长
	套路二：给出方案
		所以可以从优化sql语句入手
	套路三：具体怎么实施你的方案


优化措施1：根据业务需求，选取合适的存储引擎。
	◆你的数据库有外键吗？   innodb
	◆你需要事务支持吗？   innodb
	◆读写的数据量大吗？（大量读写）myisam
	◆你的写操作并发大吗？（更新、写入的并发大） innodb

	1）存储引擎决定了 数据在硬盘上的存储格式！
	2）常用的存储引擎：innodb、myisam
	3）innodb的特点
		①数据存储格式：每个数据表由2个文件组成：*.frm表结构文件、表空间文件（数据和索引）
			默认情况：所有的innodb表，数据和索引都存储在一个文件中ibdata1。
			通过配置，一个innodb表，生成一个对应的表空间文件。
				set global innodb_file_per_table = 1;
				*.frm和*.ibd
		②数据的存储顺序
			Innodb数据表中如果有主键，数据的存储顺序是按照主键顺序进行存储。
		③并发性
			并发处理能力比较好，innodb支持行锁。
		④对事务的支持
			支持事务。
		⑤对外键的支持
			支持外键。
		⑥对全文索引的支持
			从mysql5.6开启，支持全文索引。
	4）myisam的特点
		①数据存储格式：每个数据表由3个文件构成，*.frm表结构文件、*.MYD数据文件、*.MYI索引文件。
		②数据的存储顺序：
			存储顺序按照插入顺序来存储。适合，大批量数据的存储。
		③并发性
			并发处理能力较差，myisam只支持表锁。
		④压缩性（myisam独有的特性）：
			myisam支持对数据文件进行压缩。
			数据文件压缩后影响：
				①需要重建索引。
				②数据表变成了只读表。
		⑤对事务的支持
			不支持事务。
		⑥对外键的支持
			不支持外键。
		⑦全文索引支持
			支持全文索引。

优化措施2：选取合适的数据类型
	1）选取占据空间小的字段。例如：存储年龄，不使用int，使用tinyint。
	2）选取运行速度快的字段。例如：char比varchar运行速度快。存储固定长度的内容时，选用char。
	3）选取“整型”的数据类型
		在mysql中，尽量选择数字类型 而不用字符串类型。
		①时间信息的字段，使用无符号的整型 int进行存储:
		②状态信息的字段，选用集合、枚举类型
		③ip地址的字段，转换为整型进行存储。
优化措施3：优化执行速度慢的sql语句。
	第1步，找出执行速度慢的sql。
		工具一：慢查询日志。
			把执行时间超过某个阀值的sql语句，给记录到慢查询日志文件中。
			①开启
				方式1：使用命令，临时开启。 set global slow_query_log = 1;
					
				方式2：修改配置文件，永久开启
					log-slow-queries="d:/slow-log"
					long_query_time=1
			②设置阀值
				set  long_query_time=0.5;  
		工具二：profile机制，精确记录sql执行时间。
			1）开启：set  profiling = 1;
			2）执行sql语句【自动记录执行的时间】
			3）查看：show profiles;
		
	第2步，对sql语句进行优化。
		
		方案：让sql语句使用上索引。
		
			第1步，给数据表添加合适的索引。
				【哪些字段适合创建索引？】
					①经常作为查询条件的字段（出现在where后面的字段），适合建索引。
					②唯一性差的字段，不适合建索引。例如：性别字段。
					③字段内容频繁更新的字段，不适合建索引。
			第2步，分析sql语句有没有使用上索引。
				使用工具：mysql自带了一个工具，执行计划explain。
				explain sql语句\G
				
					possible_keys：可能用到的索引
					key：	   实际使用的索引
					row：	   需要查找的记录数量
			第3步，遵循索引的使用原则，来调整sql语句。
			
				【索引覆盖】（黄金索引）
					查询的字段恰好是索引字段, 或者 是索引字段的一部分时。
					例如：索引字段是name，sql语句：select name from 表;
					例如：索引字段是（name,age)，sql语句：select age from 表名;
					
					如何利用索引覆盖？【把经常查询的字段，创建一个复合索引】
					例如：经常查询id,name,age这3个字段，那么就创建一个复合索引(id,name,age)。
				【列独立原则】
					如果索引字段参与了条件表达式，索引字段必须独立在运算符（=、>、<） 的一侧，此时该索引才能用上。
					
					例如：
						索引字段是id, where id > xxx 。
						where id > 4;   //独立在运算符的左侧，索引能用上。
						where id > 6-2; //独立在运算符的左侧，索引能用上。
						where 6-2 < id; //独立在运算符的右侧，索引能用上。
						where id+2 = 6; //参与了运算，索引不能用上。
				【like模糊查询】
					如果索引字段参与了like模糊查询，查询的内容左边必须固定，才能使用上该索引。
					例如：
						索引字段是name, where name like '内容';
						where name like '%abc%'; //内容的左边不固定，用不上索引。
						where name like 'abc%';  //内容的左边固定，用上索引。

				【or运算】
					当or左右两侧的条件字段都有索引时，才会使用到索引（两个都用）。只有一侧字段有索引，则都不会使用。
					
					例如：where name=‘abc' or age > 20; name和age字段参与了or运算。
					
				【复合索引的最左前缀原则】
					当条件字段是复合索引最左边的列，复合索引才能用上。
					
					例如：复合索引(name,age)， 
						where name = 'abc';  //name字段是最左边的列，用上索引。
						where age = 20;		//age字段不是最左边的列，用不上索引。
						
						where name='abc' and age = 20; //用上
				【mysql智能选择】
					满足了所有的使用原则，索引也不一定能使用上！
					mysql自行判断使用索引和不使用索引所消耗的资源。
				【优化group by语句】
					mysql默认会对group by后面的字段进行排序，浪费开销。
					
					优化：避免排序的消耗，禁止对group by字段的排序！
					在语句最后使用 order by null 禁止排序。


						
						
			
				【索引的作用】快速的定位要查询的数据。
				【索引的类型】
					主键索引（primary key）：字段内容不能重复，且不能为null。
					唯一索引（unique key）：字段内容不能重复。
					普通索引（index）：
					全文索引（fulltext index）：把字段内容中的单词提取出来，作为索引的关键字。

					
				【特殊的索引】
					复合索引：把多个列，作为索引字段。
				【创建索引】
					1）建表时，创建索引。
					2）建表后，添加索引。
				【删除索引】
					1）删除主键索引
						alter table 表名 drop primary key;
						注意：如果主键字段有auto_increment属性，需要先去除这个属性。
					2）删除非主键索引
						alter table 表名 drop index 索引名;
				【查看索引】
					show create table 表名; 或者 desc 表名;
					